import java.io.*; 
import java.util.*;
import java.lang.*;
import java.awt.event.*;
import java.awt.*;
import java.awt.Font;
import java.awt.Dimension;
import java.awt.Graphics;


public class DrawTree extends Panel
{
    int XDIST, YDIST, currentX, currentY,currentStartNode;
    List XYlist, data, menuItemsList, trees, startNode;
    List featureValues = new List();
    List featureIndices = new List();
    List listOfFeatureLists = new List();
    Graphics graphics;
    boolean ready;
    static boolean omitNullFeatures= false;
    Node newNode;
    Label label;
    Font font;
    FontMetrics fontmetrics;
    // treeType indicates whether we are drawing a derived (0) or derivation tree (1)
    int treeType;
    Tree currentTree;
    PopupMenu popup;
    int depthCorrection=0;
    Font currentFont;
    // Declare a tree that will be used for drawing
    boolean incrementX = false;
    int XCorrection=0;
    Button fitButton;
    int textheight;
    
    static int treeDepth =0; // used to keep track of how deep the drawn structure is.
    List startPopupMenuItemsList;
    Hashtable featHashtable, pendingHashtable, disjunctionHashtable;
    int EXPANDED_VALUE = 0;
    int EXPANDED_INDEX = 1;
    int COLLAPSED_VALUE = 2;
    int COLLAPSED_INDEX = 3;
    int PENDING_VALUE = 4;
    int DISJUNCTION_VALUE = 5;
    
    int featIndex=0;
    int counter=0;
    int pendingCounter=0;
    int disjunctionCounter=0;
    String id_base = "id:";
    String pending_ID_Base = "pending:";
    String disjunctionBase="disj:";
    public DrawTree(int treetype){
	super();
	setBackground(Color.white);
	setLayout(null);
	currentFont = ShowTrees.currentFont;
	setFont(currentFont);
	fontmetrics = getFontMetrics(currentFont);
	treeType = treetype;
	XDIST = 50;
	YDIST = 50;
	currentX = 50 +XDIST;
	ready = false;
	menuItemsList = new List();
	if(treetype ==0){
	    fitButton = new Button("Fit");
	    fitButton.addActionListener(new ButtonAction());
	}
	textheight = fontmetrics.getHeight()+5;
    }
    
    /*
      Name: Paint
      Args: Graphics
      Returns: void 
      Description:
                  Overrides the paint method in the Panel class. Reads the list
		  of coordinate pairs that have been generated by drawTree. Each coordinate pair
		  specifies the beginning and the end of a line that connects a parent node and a child.
		  It then draws the lines between all nodes.
		  
     */

    public void paint(Graphics g){
	int count = 0;
        int childXY[];
        int parentXY[] = new int[2];
        List currentList;
        ListNode currentNode;
        ListNode l;
        boolean pcoords;
	super.paint(g);
	// if we already have all the data needed, .......
	if(ready){
	    currentNode = XYlist.head;
	    while(currentNode.next != null){
		currentList = (List)currentNode.next.data;
		currentNode = currentNode.next;
		l = currentList.head;		       
		pcoords = true;
		while(l != null){
		    if(pcoords){
			parentXY = (int[])l.data;
			pcoords = false;
		    }
		    else{
			// draw a line from the coordinates of the parent to each of the children
			childXY = (int[])l.data;
			g.drawLine(parentXY[0]+(parentXY[2]/2), parentXY[1], 
				   childXY[0]+ (childXY[2])/2, childXY[1]-textheight-childXY[3]);
		    }
		    l = l.next;
		}
	    }
	}
	// reset the currentX so that when you refresh the drawing you draw it on the same place
	currentX = 100;
    }   
    
    /*
      Name:
      Args:
      Returns:
      Description:
                 Creates a new label and sets the text to be displayed on the label. The position 
		 of the label is then set and the coordinates relevant to this label are returned
		 to the calling method
     */


    public int[] drawLeaf(TreeNode leafNode, int  depth, int dc)
    {
	int oldX, Y, xy[], width, height, leafDepth;
	if(ShowTrees.showFeatures && DerivedTrees.unification){ Y = depth * YDIST + dc; }
	else{ Y = depth * YDIST; }
	width=fontmetrics.stringWidth(leafNode.nodeLabel)+40;
	
	label = new Label(leafNode.nodeLabel.replace('', 'e'));
	label.setAlignment(Label.CENTER);
	// set the coordinates and size of the label
	label.setBounds(currentX, Y, width, textheight);
	// add the label to the panel
	add(label);
	oldX = currentX;
	// move the currentX to the right
	currentX = currentX + XDIST + width;
	xy = new int[4];
	leafDepth= Y+ textheight;
	xy[0] = oldX;
	xy[1] = leafDepth;
	xy[2] = width;
	xy[3] = 0;
	if(leafDepth > treeDepth){ treeDepth = leafDepth; }
	return xy;
    }

    /*
      Name:
      Args:
      Returns:
      Description:
                 If the node being drawn is collapseable and it is collapsed and it has a position indicated
		 then remove the position( text after the "." in the label. This ensures that NP.t is displayed as NP
		 If the node has features and the it has been set to show features, then adjust the coordinates to 
		 allow for a feature box. Check to see if the node is an adjunction or substitution node and alter the label
		 to indicate the fact.
		 Create a new Node object to be drawn and return the coordinates of where the line to the child is to be drawn
		 
     */


    public int[] drawNode(TreeNode node, int X, int depth, java.awt.List featList, int dc, List menuItemsForPopup)
    {
	int xy[] = new int[4];
	String left, right;
	String nodelabel = node.nodeLabel;
	String nodeID= node.nodeID;   
	int Y;
	int nodeDepth;
	int width=0;
	int listHeight=(int)featList.getHeight();
	// add the features to the featureListStruct. Necessary for highlighting co-indexed features
	if(node.nodeID.compareTo("Start")!=0){
	    listOfFeatureLists.put(featList);
	}
	if(node.collapseable && node.isCollapsed && nodelabel.indexOf(".") !=-1){
	    nodelabel = nodelabel.substring(0, nodelabel.indexOf("."));
	}
	// if this node has features that are to be displayed, adjust the Y position for 
	// the line from this node to its child to accomodate a features window
	if(ShowTrees.showFeatures){     Y = depth * YDIST + dc; }
	else{ 	    Y = depth * YDIST;}
	if(ShowTrees.showFeatures && DerivedTrees.unification){     width=Math.max(featList.getWidth(),fontmetrics.stringWidth(nodelabel)); }
	else{     width = fontmetrics.stringWidth(nodelabel) +40; }
	if((width/2) > (XDIST-20)){
	    if((width/2)-(XDIST-20) > XCorrection){  XCorrection = (width/2)-(XDIST-20); }
	}
	X = X-width/2;
	// get the node type
	if(treeType ==0){
	    if(node.nodeType.compareTo("*")==0){  nodelabel=nodelabel + "*"; }
	    else if(node.nodeType.compareTo("+")==0){    nodelabel=nodelabel + "+"; }
	}
	if(node.nodeID.compareTo("Start")!=0){
	    newNode = new Node(nodelabel, menuItemsForPopup, X,Y, width, textheight, node);
	}
	else{
	    newNode = new Node(nodelabel, startPopupMenuItemsList, X,Y, width, textheight, node);
	}
	add(newNode);
	featList.setLocation(X,Y+textheight);
	if(ShowTrees.showFeatures){  add(featList); }
	currentX = Math.max(X + width+20 + XDIST, currentX);
	
	if(ShowTrees.showFeatures){	     nodeDepth= Y + textheight+listHeight;  xy[3] = listHeight; }
	else{ nodeDepth=Y + textheight;   xy[3] = 0; }
	if(nodeDepth > treeDepth){ treeDepth=nodeDepth;  }
	xy[0] = X ; 
	xy[1]= nodeDepth;
	xy[2] = width;
	return xy;
    }
    
    /*
      Name:
      Args:
      Returns:
      Description:
                 Creates a popup menu items list for all the start nodes
		 Get a list containing all the start nodes
		 create new menuitems and add them to the list 
     */
    
    public void initTrees(int index){
	ListNode listnode;
	Tree temp;
	Tree subtree;
	String nodeLabel;
	MyMenuItem menuitem;
	SymAction lSymAction = new SymAction();
	boolean first=true;
	int i=0;
	// init popup menu items for startnode
	startPopupMenuItemsList = new List();
	startNode = (List)data.head.next.next.data;
	listnode = startNode.head;
	while(listnode.next != null){
	    nodeLabel = "   " + (String)listnode.next.data;    
	    if(i==index){   nodeLabel = "-> " + nodeLabel.substring(nodeLabel.indexOf("s"));  }
	    menuitem = new MyMenuItem("", "", "", nodeLabel);
	    menuItemsList.put(menuitem);
	    menuitem.addActionListener(lSymAction);
	    startPopupMenuItemsList.put(menuitem);
	    listnode = listnode.next;
	    i++;
	}
    }
    
    /*
      Name:
      Args:
      Returns:
      Description:
                 Finds the tree with startnode number corresponding to index in the list of trees
		 Process the features for the given tree
		 Push the features to their proper locations in the tree
		 Process the tree and the call drawTreeRecursive to render the tree to the display
		 
    */
    
    public void drawTree(int index){ // index: refers to the start node
	ListNode listnode;
	Tree subtree;
	int i;
	// initialize the start menuitems
	initTrees(index);
	// reset tree depth
	treeDepth=0;
	// set the current start node
	currentStartNode =index;
	// list of all the trees anchored by "start" nodes 
	trees = (List)data.head.next.data;
	// create a new list to hold all the coordinates for the labels
	XYlist = new List();
	// find the subtree at the given index from the list of trees anchored by "start" nodes
	i = 0;
	listnode = trees.head;
	while(listnode.next != null){
	    // find the tree from the list
	    if(i == index){
		currentTree= (Tree)listnode.next.data;
		// check if the current tree has been processed
		if(!currentTree.root.processed && treeType==0){
		    // if the tree has not been process already, process it now
		    featHashtable = new Hashtable(200);
		    pendingHashtable = new Hashtable(20);
		    disjunctionHashtable = new Hashtable(20);
		    processFeatures(currentTree.root);
		    pushFeatures(currentTree.root.fc);
		    processTree(currentTree.root);
		    // set flag to indicate that tree has been processed
		    currentTree.root.processed=true;
		    featIndex=0;
		    counter = 0;
		    pendingCounter = 0;
		    disjunctionCounter = 0;
		    listOfFeatureLists = new List();
		}
		break;
	    }
	    listnode = listnode.next;
	    i++;
	}
	// draw the tree
	drawTreeRecursive(currentTree.root, 1,  0);
	if(treeType==0){
	    fitButton.setBounds(0,0,fontmetrics.stringWidth("Fit")+40,textheight);
	    add(fitButton);
	}
	setBounds(0, 50,currentX + 50, treeDepth+50);
    }
    

    /*
      Name:
           drawTreeRecursive
      Args:
           TreeNode root: Root node of the subtree being drawn
	   int depth: The current depth at which the root node is located in the tree
	   int depthCorrection: This is the amount by which the Y position at which this root node is 
	                        to be drawn is to be corrected by when features are also being displayed.
				When there are no features, this value is 0.
      Returns:
           int[]: The array contains information about the (x,y) coordinates of there the node has been drawn
	          and also the width of the node. This information is used to draw lines connecting the nodes
      Description:
            checks to see if this node is a leaf. If it is, draw the leaf and return its coordinates and width
	    Otherwise, if the tree is of type 1=>derivation tree, then draw all the nodes that are present in the tree.
	    If the tree is of type 0=>derived tree, then proceed as follows:
	        get the list of features at the root node and the list of any menuitems that will be added to the node
		check to see if the node is collapeable. If it is, check to see if the node is collapsed or expanded
		If it is collapsed, skip all the nodes that are collapsed into the root. Otherwise, draw all the nodes that would
		normally be collapsed into this node.
		If features are being displayed, find the relevant features associated with this node and add them to a list. Compute the 
		correction to be applied when drawing this node.
		Recursively draw the children of this node. Then draw this root.
		
		
		
      
     */
    
    public int[] drawTreeRecursive(TreeNode root, int depth, int depthCorrection){
	
	// booleans
	boolean firstChild; // flag indicating that current node is a first child of some node
	boolean end = false;// indicates that last child has been reached
	// integer arrays
	int xy[];           // holds the coordinates and width information about a component added to the canvas
	int lastXY[] = new int[3]; // coordinates for the last child of a node
	int firstXY[]= new int[3]; // coordinates for the first child of a node
	// integers
	int midpoint;              // midpoint along the X-axis between first and last child
	int listHeight=0;
	int listWidth=0;
	int featMaxLen=0;
	int countRows=0;
	// strings
	String nodeLabel;          // the label of a node to be displayed
	String fs;
	String value=null;
	String index;
	Feature feat;
	Vector featVector;
	MyMenuItem menuitem;
	
	List pList;
	// ListNodes
	ListNode listnode, featListNode;
	java.awt.List featList; 
	
	// Tree Nodes
	TreeNode currNode;
	List features = new List();
	List collapsedNodeFeatures = root.collapsedNodeFeatures;
	List menuItemsListForPopup;
	String stored[];
	FeatListListener itemListener = new FeatListListener();
	featList = new java.awt.List();
	featList.addItemListener(itemListener);
	featList.setBackground(Color.white);
	featList.setSize(0,0);
	menuItemsListForPopup = new List();
	
	// if the node is a leaf, draw it and return the coordinates of where it was drawn
	if(root.fc == null){
	    return drawLeaf(root, depth, depthCorrection);
	}
	// create a new list to contain the coords for this parent and all it children
	pList = new List();
	// if the tree type is a derivation tree, draw all the nodes. There is NO merging of nodes
	if(treeType == 1){
	    // set the menuItems for the root
	    menuItemsListForPopup = createMenuItemsForNode(root, 1);
	    menuItemsListForPopup.concatenate(root.collapsedNodeMenuItems);
	    currNode = root.fc;
	}
	else{ 
	    // get root features and the menuitems
	    features.concatenate(root.features);
	    menuItemsListForPopup.concatenate(root.menuItems);
	    // if this node can hide others
	    if(root.collapseable){
		// if all nodes are collapsed, force all collapseable nodes into collapsed states
		if(ShowTrees.collapseNodes){  root.isCollapsed=true; }
		else if(ShowTrees.expandNodes){ root.isCollapsed=false; }
		// see if the node is currently collapsed or expanded
		if(root.isCollapsed){    
		    // follow the pointer to the next node to be drawn
		    currNode = root.marker; 
		    features = collapsedNodeFeatures;
		    // add the menu items for nodes collapsed into the root to the root's menu items
		    menuItemsListForPopup.concatenate(root.collapsedNodeMenuItems);
		}
		else{  currNode = root.fc; }
	    }
	    // otherwise, follow the pointer to the next node to be drawn
	    else{  currNode = root.fc; }
	    // if the features are not null
	    if(features != null){
		// add all the features belonging to the current root to this featList
		featListNode = features.head;
		while(featListNode.next != null){
		    value=null;
		    feat = (Feature)featListNode.next.data;
		    fs = feat.feature;
		    if(root.collapseable && root.isCollapsed){
		    	stored = (String[])featHashtable.get(feat.id);
		    	index = stored[COLLAPSED_INDEX];
			
		    	if(stored[DISJUNCTION_VALUE] !=null){  value = (String)disjunctionHashtable.get(stored[DISJUNCTION_VALUE]);  }
			else{value = stored[COLLAPSED_VALUE]; }
			if(value == null && stored[PENDING_VALUE] !=null){
			    // check to see if this feature had a pending value that was later set and entered into the pendingHashtable
			    if(pendingHashtable.containsKey(stored[PENDING_VALUE])){
				value = (String)pendingHashtable.get(stored[PENDING_VALUE]);
				// if the value stored is a pointer to a value that was a disjunction, get the real value
				if(value.startsWith(disjunctionBase)){
				    value = (String)disjunctionHashtable.get(value);
				}
			    }
			}
		    }
		    else{
		    	stored = (String[])featHashtable.get(feat.id);
			index = stored[EXPANDED_INDEX];
		    	value = stored[EXPANDED_VALUE];
		    }
		    
		    // create the string that will be displayed  in the feature list
		    if(value==null && omitNullFeatures){
			// do not add the feature to the list if it has no value
		    }
		    else{
			if(value !=null){  value = value.replace('', ' '); }
			fs=fs.replace('', ' ');
			fs = fs.substring(fs.indexOf(":")+1);
			if(value !=null && value.indexOf(";") !=-1){
			    StringTokenizer tok = new StringTokenizer(value, ";");
			    int toks = tok.countTokens();
			    int j=0;
			    String t=tok.nextToken();
			    String blank = "";
			    if(toks > 1){
				int l = fs.length();
				for(int i=0; i<l; i++){  blank = blank + " ";}
			    }
			    fs = fs + "=[" + index + "]" + t;
			    featList.add(fs);
			    j++;
			    countRows++;
			    if(fontmetrics.stringWidth(fs) > listWidth){     listWidth = fontmetrics.stringWidth(fs); }
			    while(j < toks){
				j++;
				t=tok.nextToken();
				fs=blank + "=[" + index +"]" + t;
				featList.add(fs);
				countRows++;
				if(fontmetrics.stringWidth(fs) > listWidth){     listWidth = fontmetrics.stringWidth(fs); }
			    }
			}
			else{
			    fs = fs + "=[" + index + "]" + value;
			    // find the width of the longest features
			    if(fontmetrics.stringWidth(fs) > listWidth){     listWidth = fontmetrics.stringWidth(fs); }
			    // add this feature to the feature list of this node
			    featList.add(fs);
			    countRows++;
			}
		    }
		    featListNode = featListNode.next;
		}
		if(countRows > 0){
		    // compute the necessary height needed to display the feature's List
		    if(ShowTrees.maxFeat > 0 && ShowTrees.maxFeat < countRows){
			listHeight = (fontmetrics.getHeight()+2) * ShowTrees.maxFeat;
		    }
		    else{  listHeight = (fontmetrics.getHeight()+2) * countRows; }
		    featList.setSize(listWidth,listHeight);
		}
	    }
	}
	//draw all the subtrees starting with the first child
	firstChild = true;
	while(!end){
	    if(ShowTrees.removeInserted){
		if(currNode.isInserted){
		    List siblings;
		    ListNode ln;
		    TreeNode nextSibling;
		    xy=null;
		    // get all the siblings that are at this artificial node
		    siblings = processArtificial(currNode,menuItemsListForPopup);
		    // set the currNode to the first node in the list
		    ln=siblings.head;
		    // draw all the siblings
		    while(ln.next != null){
			nextSibling = (TreeNode)ln.next.data;
			xy= drawTreeRecursive(nextSibling, depth+1, depthCorrection+listHeight);
			pList.put(xy);
			if(firstChild){     firstXY = xy;   firstChild = false; }
			ln = ln.next;
		    }
		    if(currNode.terminal){ lastXY=xy;  break; } 
		    else{ currNode = currNode.ns; }
		}
	    }
	    // check to see if the current node is an inserted node and if you are to remove it
	    xy= drawTreeRecursive(currNode, depth+1, depthCorrection+listHeight);
	    // add the coordinates of the child to the pList
	    pList.put(xy);
	    // remember the coordinates of the first and last child, used compute the midpoint between the first and last child where the parent will be drawn
	    if(firstChild){     firstXY = xy;   firstChild = false; }
	    // if this is the last child of this node, memorize its coordinates 
	    if(currNode.terminal){  end=true;  lastXY = xy; }
	    // otherwise go to the next sibling
	    else{      currNode = currNode.ns; }
	}
	// compute the midpoint between the first and last child on the horizontal axis
	midpoint = (firstXY[0] + lastXY[0] + lastXY[2]) / 2 ;
	// show the node that was the parent(root) to the children and add its coordinates to the head of the list
	xy = drawNode(root, midpoint, depth, featList, depthCorrection, menuItemsListForPopup);
	pList.head.data = xy;
	XYlist.put(pList);
	// add the coordinates of this node to the result
	return xy;
    }
    
    public List processArtificial(TreeNode node, List menuItemsForPopup){
	TreeNode tn;
	List menuItems;
	List result = new List();
	List siblings = new List();
	// skip all nodes e.t (they do not contain any info
	if(node.nodeType.compareTo("t")==0){  node = node.fc; }
	// concatenate menuitems
	menuItemsForPopup.concatenate(createMenuItemsForNode(node, 1));
	tn=node.fc;
	if(tn.isInserted){
	    result = processArtificial(tn,menuItemsForPopup);
	    siblings.concatenate(result);
	    siblings.put(tn.ns);
	}
	else{
	    siblings.put(tn);
	    if(tn.ns.isInserted){
		result = processArtificial(tn.ns,menuItemsForPopup);
		siblings.concatenate(result);
	    }
	    else{  siblings.put(tn.ns); }
	}
	return siblings;
    }
    
    class SymAction implements java.awt.event.ActionListener
    { 
       	public void actionPerformed(java.awt.event.ActionEvent event)
	{
	    ListNode listnode;
	    Object object = event.getSource();
	    // check if the event came from  a popup menu item
	    listnode = menuItemsList.head;
	    if(listnode.next != null){
		while(listnode.next != null){
		    if(object == listnode.next.data){
			popupMenuItemActionPerformed(event);
			break;
		    }
		    listnode = listnode.next;
		}
	    }  
	}
    }
    
    void popupMenuItemActionPerformed(ActionEvent e){
        String label;
        String treeN;
	String leftdtr, rightdtr, parent;
        int treeNumber;
        ListNode derivedTreesListnode, derivationTreesListnode;
	Node n;
	Tree newSubTree;
	PopupMenu pm;
	
        // get the source of the event
        MyMenuItem actionSource = (MyMenuItem)e.getSource();
        // check the label to see if it a start node
        label = actionSource.getLabel();
	
	pm = (PopupMenu)actionSource.getParent();
	 // get the parent of the popup menu
	n = (Node)pm.getParent();
        

	if(label.indexOf("start")!=-1){
	    // get the start node number
	    treeN = label.substring(label.indexOf('_')+1, label.indexOf(':'));
	    treeNumber= Integer.parseInt(treeN);
	    // if a different start node has been selected
	    if(treeNumber != currentStartNode){
		// get the tree from the "trees" list
		if(ShowTrees.drawDerivedTree != null){
		    ShowTrees.drawDerivedTree.removeAll();
		    ShowTrees.drawDerivedTree.ready = false;
		    ShowTrees.drawDerivedTree.drawTree(treeNumber);
		    ShowTrees.drawDerivedTree.ready = true;
		    ShowTrees.drawDerivedTree.repaint();
		}
		if(ShowTrees.drawDerivationTree != null){
		    ShowTrees.drawDerivationTree.removeAll();
		    ShowTrees.drawDerivationTree.ready = false;
		    ShowTrees.drawDerivationTree.drawTree(treeNumber);
		    ShowTrees.drawDerivationTree.ready = true;
		    ShowTrees.drawDerivationTree.repaint();
		}
	    }
	}
	// if action source is an alternative daughter pair...
	else if(label.startsWith("Collapse Node")){
	    // reset the ShowTrees flags to false
	    ShowTrees.collapseNodes=ShowTrees.expandNodes=false;
	    actionSource.setLabel("Expand Node"); 
	    // set the flag to true so that when the tree is redraw, it will be in collapsed mode
	    n.treeNode.isCollapsed=true;
	    // redraw the tree
	    removeAll();
	    XYlist = new List();
	    ready = false;
	    drawTree(currentStartNode);
	    ready = true;
	    repaint();
	}
	else if(label.startsWith("Expand Node")){
	    // change the label on the menu item so that the next call is to collapse the node
	    actionSource.setLabel("Collapse Node");
	    // reset the ShowTrees flags to false
	    ShowTrees.collapseNodes=ShowTrees.expandNodes=false;
	    // set the flag to false so that when the tree is redraw, it will be in expanded mode
	    n.treeNode.isCollapsed=false;
	    // redraw the tree
	    removeAll();
	    XYlist = new List();
	    ready = false;
	    drawTree(currentStartNode);
	    ready = true;
	    repaint();
	}    
	else{
	    // get the nodeIDs for left and right daughters
	    parent = actionSource.parent;
	    leftdtr = actionSource.leftChild;
	    rightdtr = actionSource.rightChild;
	    XYlist = new List();
	    // remove the current daughter pair that is being used from the hashtable
	    if(DerivedTrees.altered.containsKey(parent)){
	        DerivedTrees.altered.remove(parent);
	    }
	    // put into the hashtable the new daughter pair that has just been selected by user
	    DerivedTrees.altered.put(parent,leftdtr + "," + rightdtr );
	     if(ShowTrees.drawDerivedTree != null){
		ShowTrees.drawDerivedTree.removeAll();
		ShowTrees.drawDerivedTree.data = ShowTrees.dtrees.computeDerived();
		ShowTrees.drawDerivedTree.drawTree(ShowTrees.drawDerivedTree.currentStartNode);
		ShowTrees.drawDerivedTree.ready = true;
		ShowTrees.drawDerivedTree.repaint();
	    }
	    // redraw the derivation trees
	    if(ShowTrees.drawDerivationTree != null){
		ShowTrees.drawDerivationTree.removeAll();
		ShowTrees.drawDerivationTree.data = ShowTrees.dtrees.computeDerivation();
		ShowTrees.drawDerivationTree.drawTree(ShowTrees.drawDerivationTree.currentStartNode);
		ShowTrees.drawDerivationTree.ready = true;
		ShowTrees.drawDerivationTree.repaint();
	    }
	}
    }

    
    
    class ButtonAction implements java.awt.event.ActionListener
    { 
	public void actionPerformed(java.awt.event.ActionEvent event)
	{
	    Object object = event.getSource();
	    if(object==fitButton){
		fitButtonAction(event);
	    }
	}
    }
    public void fitButtonAction(ActionEvent e){
	// if the features are being displayed increment the XDIST variable to the XCorrection value, then XCorrection to 0.
	if(ShowTrees.showFeatures){
	    XDIST=XDIST+XCorrection;
	    XCorrection=0;
	}
	else{ XDIST = 50; }
	// reset the XYList to a new empty list
	XYlist = new List();
	// redraw the tree
	removeAll();
	ready = false;
	drawTree(currentStartNode);
	ready = true;
	repaint();
    }

    /*
      Name:
          processTree
      Args:
          Tree
      returns:
          void
      Description:
          When a tree is created by computeDerived(), the feature lists are stored at the 
	  root nodes in the tree and all other nodes do not have any features set. The purpose of this
	  function is to do a downward distribution of the features to the nodes that are spanned by the
	  root nodes
     */
    
    public void processTree(TreeNode root)
    {
	TreeNode child;
	TreeNode marker;
	boolean terminalChild=false;
	boolean end = false;
	// get the features of the root node
	List collapsedNodesFeatures = new List();
	List collapsedNodesMenuItems= new List();
	List auxPath = new List();
	List collapsedNodes = new List();
	boolean stopDescent = false;
	boolean collapseable = false;
	// if the node has no child, return immediately
	if(root.fc == null){ 
	    return; 
	}
	child = root.fc;
	// if the current root is a top node, 
	if(root.nodeType.compareTo("t") ==0 || root.nodeType.compareTo("s")==0){
	    // collapse all nodes that are not in "top" or "start" positions 
	    while((child.nodeType.compareTo("t") != 0) && (child.nodeType.compareTo("l") != 0) &&
		  (child.nodeType.compareTo("*") != 0) && (child.nodeType.compareTo("+") != 0)){
		// set the collapsible flag to true
		collapseable=true;
		// get the relevant features for all the nodes collapsed into this node
		collapsedNodesFeatures.concatenate(getRelevantFeatures(child));
		// get the menuitems for this node
		collapsedNodesMenuItems.concatenate(createMenuItemsForNode(child, 0));
		// remember all the children which may be collapsed into this root
		collapsedNodes.put(child.nodeID);
		// move to the first child of the current child
		child = child.fc;
	    }
	    if(collapseable){  root.marker = child; }
	}
	else if(root.nodeType.compareTo("*") ==0 || root.nodeType.compareTo("+")==0){
	    while(!stopDescent){
		if(child.nodeType.compareTo("l") == 0){   break;  }
		else if(child.nodeType.compareTo("b") ==0 ){ stopDescent=true; }
		collapseable=true;
		collapsedNodesFeatures.concatenate(getRelevantFeatures(child));
		collapsedNodesMenuItems.concatenate(createMenuItemsForNode(child, 0));
		collapsedNodes.put(child.nodeID);
		child = child.fc;
	    }
	    // set a pointer which will be used to omit collapsed nodes
	    if(collapseable){    root.marker = child; }
	}
	// set a flag to inicate whether this node is collapseable or not
	root.collapseable = collapseable;
	
	// create menuitems for root
	createMenuItemsForNode(root, 0);
	//set the features for root node
	getRelevantFeatures(root);
	// set the collapsedNode features for this node
	if(!collapsedNodesFeatures.isEmpty()){   
	    //System.out.println("Collapsing features for: " + root.nodeLabel);
	    root.collapsedNodeFeatures=collapseFeatures(root.features, collapsedNodesFeatures); 
	}
	if(!collapsedNodesMenuItems.isEmpty()){  root.collapsedNodeMenuItems = collapsedNodesMenuItems; }
	root.collapsedNodes = collapsedNodes;
	
	while(!terminalChild){
	    // call this procedure each child
	    processTree(child);
	    if(child.terminal){ terminalChild=true;  } 
	    // otherwise, move to the next child
	    else{  		 child=child.ns; }
	}
	
	
	
    }
    
    public List createMenuItemsForNode(TreeNode node, int treeType){
	String nodeID;
	String daughters="";
	String dtrPair="";
	String left;
	String right;
	String llabel;
	String rlabel;
	String alteredDtrPair=null;
	String menuLabel;
	MyMenuItem menuitem, topMenuItem=null;
	boolean isActiveMenuItemSet=false, isFirstMenuItem;
	List menuItemsForPopup = new List();
	StringTokenizer dtrOrList;
	int  countDtrs;
	int j;
	List nodeList = new List(); 
	ListNode listnode;
	SymAction lSymAction = new SymAction();
	boolean isAltered=false;
	if(!node.nodeID.startsWith("Start")){
	    nodeList.put(node.nodeID);
	    if(treeType==1){  
		nodeList.concatenate(node.compressedNodes);  
	    }
	    else{
		 if(node.collapseable){
		     if(node.isCollapsed){  menuitem = new MyMenuItem(node.nodeID,"","","Expand Node");   }
		     else{ menuitem = new MyMenuItem(node.nodeID,"","","Collapse Node");  }
		     //register a listener
		    menuitem.addActionListener(lSymAction);
		    menuItemsForPopup.put(menuitem);
		    menuItemsList.put(menuitem);
		 }
	    }
	    // if this is a derived tree, first menuitem is "Expand Node" initially for all collapseable nodes
	    listnode = nodeList.head;
	    isFirstMenuItem = true;
	    while(listnode.next !=null){
		nodeID=(String)listnode.next.data;
		daughters=((graphNode)DerivedTrees.graph.get(nodeID)).daughters;
		// check to see if this daughter pair has been entered into the 'altered' hashtable
		if(DerivedTrees.altered.containsKey(nodeID)){ 
		    alteredDtrPair = (String)DerivedTrees.altered.get(nodeID);
		    isAltered = true; 
		}
		else{  isAltered=false;  }
		// for each daughter pair, [nodeID, nodeID]
		if(daughters != null){
		    dtrOrList= new StringTokenizer(daughters, "]");
		    countDtrs =dtrOrList.countTokens();
		    // otherwise, get the results by computing the AND results of the first daughter pair
		    j = 0;

		    if(countDtrs > 1){
			while(j < countDtrs){
			    dtrPair= (dtrOrList.nextToken()).substring(1);
			    // split each pair into left and right
			    left = dtrPair.substring(0, dtrPair.indexOf(","));
			    right =  dtrPair.substring(dtrPair.indexOf(",")+1);
			    // get the nodeLabel for left and right
			    llabel = ((graphNode)DerivedTrees.graph.get(left)).treeName; 
			    rlabel = ((graphNode)DerivedTrees.graph.get(right)).treeName;
			    menuLabel = "   " + llabel + "," + rlabel;
			    if(isAltered && dtrPair.compareTo(alteredDtrPair)==0){
				menuLabel = "-> " + menuLabel.substring(menuLabel.lastIndexOf(" ")+1);
				isActiveMenuItemSet = true;
			    }
			    // create a menuItem with "Left Nodelabel, Right Nodelabel" as the label
			    menuitem = new MyMenuItem(nodeID, left, right, menuLabel);
			    if(isFirstMenuItem){ 
				topMenuItem = menuitem; 
				isFirstMenuItem = false; 
			    }
			    // register  an event listener for this menuItem
			    menuitem.addActionListener(lSymAction);
			    // add this menuItem to the global menuItemsList
			    menuItemsList.put(menuitem);
			    // add the menu item to the list;
			    menuItemsForPopup.put(menuitem);
			    j++;
			}
		    }
		}
		listnode=listnode.next;
	    }
	    if(!isActiveMenuItemSet && topMenuItem != null){
		// set the label of the top menuitem
		menuLabel = topMenuItem.getLabel();
		topMenuItem.setLabel("-> " + menuLabel.substring(menuLabel.lastIndexOf(" ")+1));
	    }
	    // set the menuItems for this node
	    node.menuItems = menuItemsForPopup;
	}
	else{
	    
	}
	return menuItemsForPopup;
    }
    

    /*
      Name:
           getRelevantFeatures
      Args:
           TreeNode
      Returns:
           a List of features that belong to this Node
      Description:
           This function extracts all the features from a features list stored in the node
	   and determines which features belong to this node. Any features that belong to a node
	   are added to a list which is returned
    */

    public List getRelevantFeatures(TreeNode node)
    {
	List featList=null;
       	List features=node.features;
	ListNode featListNode;
	String feature="";
	String value;
	Integer index;
	Feature feat;
	// check to see that the features are not null
	if(features != null){
	    featList= new List();
	    
	    // add all the features belonging to the current root to this featList
	    featListNode = features.head;
	    while(featListNode.next != null){
		feat = (Feature)featListNode.next.data;
		
		// check if the feature belongs to this node
		if(feat.nodeLabel.compareTo(node.nodeLabel)==0){
		    featList.put(feat);
		}
		else{
		    //System.out.println("Failed to match Node: " + node.nodeLabel + " with Feature: " + feat.feature);
		}

				
		featListNode = featListNode.next;
	    }
	    // set the features list of this node to contain features that belong to this node only
	    node.features=featList;
	}
	// return the list to the calling function
	return featList;
    }
    
    /*
      Name:
          processFeatures
      Args:
          TreeNode node
      Returns:
          Void
      Description:
             for each node in the subtree rooted at "node", each of the features in the features list
	     is processed to set the index and value. The feature list of the node is then set to the updated 
	     feature list that contains indices and values
    */


    public void processFeatures(TreeNode node){
	TreeNode child;
	boolean terminal=false;
	// set the features of this current node to the value after index and value have been set
	node.features = setFeatureIndexAndValue(node.features);
	// get the first child of this node
	child = node.fc;
	if(child != null){
	    // while we have not reached the rightmost(terminal) child of this node
	    while(!terminal){
		// process its features
		processFeatures(child);
		// check if this child is the terminal child
		if(child.terminal){
		    terminal=true;
		}
		// otherwise set the child to be the sibling on the right of the current child
		else{
		    child=child.ns;
		}
	    }
	}
    }
    
    public String getValue(List features, String feature, List result, Hashtable memo, String featIndex){
	ListNode ln;
	String feat;
	String lhs, rhs;
	String indexAndValue[];
	String id="";
	boolean matched=false;
	ln = features.head;
	while(ln.next !=null){
	    // get the feature at current listnode
	    feat = (String)ln.next.data;
	    // get the left and right values
	    lhs = feat.substring(0, feat.indexOf("="));
	    rhs = feat.substring(feat.indexOf("=")+1);
	    // locate the correct feature whose value you are trying to get
	    if(lhs.compareTo(feature)==0){
		matched=true;
		// if value already assigned to rhs, set the value of the id to be returned
		if(memo.containsKey(rhs)){
		    id = (String)memo.get(rhs);
		}
		// if the rhs is a value, create a new id 
		else if(rhs.indexOf(":<") == -1){
		    id = id_base + counter;
		    counter++;
		    indexAndValue = new String[6];
		    indexAndValue[EXPANDED_VALUE]=rhs;
		    indexAndValue[EXPANDED_INDEX]=featIndex;
		    indexAndValue[COLLAPSED_VALUE]=null;
		    indexAndValue[COLLAPSED_INDEX]=null;
		    indexAndValue[PENDING_VALUE]=null;
		    if(rhs.indexOf("/") != -1){  
			indexAndValue[DISJUNCTION_VALUE]= disjunctionBase+disjunctionCounter; 
			disjunctionHashtable.put(indexAndValue[DISJUNCTION_VALUE], rhs);
			disjunctionCounter++;
		    }
		    else{
			indexAndValue[DISJUNCTION_VALUE]= null;
		    }
		    featHashtable.put(id, indexAndValue);
		}
		// otherwise, just recurse on the rhs, i.e. now see if you can find the value for rhs
		else{
		    id = getValue(features, rhs, result, memo, featIndex);
		}
		break;
	    }
	    ln = ln.next;
	}
	if(!matched){  
	    id = id_base + counter;
	    counter++;
	    indexAndValue = new String[6];
	    indexAndValue[EXPANDED_VALUE]=null;
	    indexAndValue[EXPANDED_INDEX]=featIndex;
	    indexAndValue[COLLAPSED_VALUE]=null;
	    indexAndValue[COLLAPSED_INDEX]=null;
	    indexAndValue[PENDING_VALUE]=null;
	    indexAndValue[DISJUNCTION_VALUE]= null;
	    featHashtable.put(id, indexAndValue);
	}
	memo.put(feature, id);
	result.put(new Feature(feature, id));
	return id;
    }
    
    public String getValueOfRHS(Hashtable memo, String rhs, List features, List result){
	Feature rhsFeat, feature;
	String id;
	String indexAndValue[];
	// if the rhs has already been memorized
	if(memo.containsKey(rhs)){
	    // return the id of the rhs
	    return (String)memo.get(rhs);
	}
	// otherwise if the RHS is a value
	else if(rhs.indexOf(":<") == -1){
	    indexAndValue = new String[6];
	    indexAndValue[EXPANDED_VALUE]=rhs;
	    indexAndValue[EXPANDED_INDEX]=""+featIndex; // convert integer to string
	    indexAndValue[COLLAPSED_VALUE]=null;
	    indexAndValue[COLLAPSED_INDEX]=null;
	    indexAndValue[PENDING_VALUE]=null;
	    if(rhs.indexOf("/") != -1){  
		indexAndValue[DISJUNCTION_VALUE]= disjunctionBase+disjunctionCounter; 
		disjunctionHashtable.put(indexAndValue[DISJUNCTION_VALUE], rhs);
		disjunctionCounter++;
	    }
	    else{
		indexAndValue[DISJUNCTION_VALUE]= null;
	    }
	    id = id_base + counter;
	    featHashtable.put(id, indexAndValue);
	    counter++;
	    // increment featIndex
	    featIndex++;
	}
	// otherwise the rhs is a feature but its value and index have not been set yet. Set them.
	else{
	    id = getValue(features, rhs, result, memo, ""+featIndex);
	    featIndex++;
	}
	return id;
    }

    public List setFeatureIndexAndValue(List features){
	String feat;
	String lhs, rhs;
	ListNode ln;
	List result = new List();
	Feature feature;
	Hashtable memo = new Hashtable(40);
	String cfeat="";
	boolean complexFeature;
	String id;
	String stored[], stored1[];
	if(features == null){
	    return null;
	}
	// for every feature in the list, set the index and value
	ln = features.head;
	while(ln.next != null){
	    // get feature at the current listnode
	    feat = (String)ln.next.data;
	    // get the left and right values
	    lhs = feat.substring(0, feat.indexOf("="));
	    rhs = feat.substring(feat.indexOf("=")+1);
	    // check to see if the feature is a complex feature
	    if(lhs.indexOf("") != -1){
		// set the lhs to the feature
		lhs = lhs.substring(0, lhs.indexOf("")) + ">";
		cfeat = "<"+feat.substring(feat.indexOf("")+1, feat.indexOf("="));
		complexFeature = true;
	    }
	    else{   complexFeature=false; }
	    // if the lhs has already been memorized, i.e. it has already been processed and entered into the result list, skip it
	    if(!memo.containsKey(lhs) && !lhs.startsWith("Dn.t")){
		// process the rhs associated with the lhs and get a unique id for retrieving the result for the hashtable
		id = getValueOfRHS(memo,rhs,features, result);
		// if the feature is complex,
		if(complexFeature){
		    // get the value stored at the id and modify it
		    stored = (String[])featHashtable.get(id);
		    stored[EXPANDED_VALUE]=cfeat + "=" + stored[EXPANDED_VALUE];
		    // store it back into the hashtable
		    featHashtable.put(id, stored);
		}
		// create a new feature with the id which will be used to locate its value and index and add it to the result
		result.put(new Feature(lhs, id));
		// memorize the id of lhs
		memo.put(lhs, id); 
	    }
	    // if feature is complex and has already been entered into memo and therefore also entered into featHashtable
	    else if(complexFeature){
		// get the memorized feature from the featHashtable
		stored = (String[])featHashtable.get((String)memo.get(lhs));
		// if the rhs is a value, set value for the complex feature 
		if(rhs.indexOf(":<") == -1){ cfeat = cfeat + "=" + rhs; }
		// otherwise process the rhs to get the value
		else{
		    id = getValueOfRHS(memo,rhs,features, result);
		    // get the memorized feature from the featHashtable
		    stored1 = (String[])featHashtable.get(id);
		    // add the value for the complex feature
		    cfeat=cfeat + "=" + stored1[EXPANDED_VALUE];
		}
		// update the current value stored
		if(stored[EXPANDED_VALUE] != null){ stored[EXPANDED_VALUE] =stored[EXPANDED_VALUE] + ";" + cfeat; }
		else{ stored[EXPANDED_VALUE]=cfeat; }
		// store the result back into the hashtable
		featHashtable.put((String)memo.get(lhs), stored);
	    }
	    ln = ln.next;
	}
	return result;
    }

   

    public List collapseFeatures(List f1, List f2){ // f1: contains features belonging to the current node only, f2: features for all nodes that have been  collapsed
	List result = new List();
	ListNode ln1, ln2;
	Feature feat1, feat2;
	String data;
	String token, value1, value2, value="";
	int i=0;
	int numTokens;
	StringTokenizer tokenizer;
	String stored1[], stored2[];
	boolean matched=false;
	// if both lists are null, return null immediately
	if(f1 == null && f2 == null){   
	    //System.out.println("both feature lists are null");
	    return null; 
	}
	// otherwise if one of the lists is null, return the non-null feature list
	else if(f1==null){   
	    //System.out.println("feature list f1 is null");
	    return f2; 
	}
	else if(f2== null){   
	    //System.out.println("feature list f2 is null");
	    return f1; 
	}
	// for each of the features in f1, find the features in f2 with the same node base and the same type and merge the features
	ln1 = f1.head;
	while(ln1.next !=null){
	    // get a feature from f1
	    feat1 = (Feature)ln1.next.data;
	    //System.out.println("Feature 1: " + feat1.feature);
	    stored1 = (String[])featHashtable.get(feat1.id);
	    // find a feature from f2 with the same nodebase and type
	    ln2 = f2.head;
	    matched=false;
	    while(ln2.next !=null){
		feat2 = (Feature)ln2.next.data;
		//System.out.println("Feature 2: " + feat2.feature);
		// if the nodebase and type are the same
		if(feat1.nodeBase.compareTo(feat2.nodeBase)==0 && feat1.type.compareTo(feat2.type)==0){
		    matched = feat2.matched=true;
		    stored2 = (String[])featHashtable.get(feat2.id);
		    // if both values are null, set an indicator that there are values that are pending for these features
		    if(stored1[EXPANDED_VALUE]==null && stored2[EXPANDED_VALUE]==null){   
			// if stored1[PENDING_VALUE] != null, set the pending id for retrieveing the pending value from the pendingHashtable
			if(stored1[PENDING_VALUE] != null){  stored2[PENDING_VALUE] = stored1[PENDING_VALUE]; }
			// otherwise, set the id for retrieving the pending value for both features
			else{
			    stored1[PENDING_VALUE] = stored2[PENDING_VALUE] = pending_ID_Base + pendingCounter;
			    pendingCounter++;
			}
			// set the collpased index 
			if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			stored2[COLLAPSED_INDEX]=stored1[COLLAPSED_INDEX];
		    }
		    // if the value for the feat1 is null....
		    else if(stored1[EXPANDED_VALUE]==null){  
			/* if there is an id for the pending value set in stored1[PENDING_VALUE], set the pending value to be the
			   value of feat2 in pendingHashtable */

			if(stored1[PENDING_VALUE] != null && stored2[DISJUNCTION_VALUE]!=null){
			    // store in the pending hashtable the id to the disjunction value
			    pendingHashtable.put(stored1[PENDING_VALUE], stored2[DISJUNCTION_VALUE]); 
			}
			else if(stored1[PENDING_VALUE] != null){
			    pendingHashtable.put(stored1[PENDING_VALUE],stored2[EXPANDED_VALUE]); 
			}
			else if(stored2[DISJUNCTION_VALUE]!=null){
			    stored1[DISJUNCTION_VALUE]=stored2[DISJUNCTION_VALUE];
			}
			else{
			    stored1[COLLAPSED_VALUE] = stored2[EXPANDED_VALUE];
			}
			// set the collapsed index
			if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			stored2[COLLAPSED_INDEX]=stored1[COLLAPSED_INDEX];
		    }
		    // if the value of feat2 is null, just set its value to the value of feat1
		    else if(stored2[EXPANDED_VALUE]==null){  
			stored1[COLLAPSED_VALUE] = stored1[EXPANDED_VALUE];
			stored2[COLLAPSED_VALUE] = stored1[EXPANDED_VALUE];
			if(stored1[DISJUNCTION_VALUE] != null){
			    stored2[DISJUNCTION_VALUE]=stored1[DISJUNCTION_VALUE];
			}
			if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			stored2[COLLAPSED_INDEX]=stored1[COLLAPSED_INDEX];
		    }
		    // if feat1 and feat2 have the same value, set the index of feat2 to the index of feat1 and set 
		    else if((stored1[EXPANDED_VALUE]).compareTo(stored2[EXPANDED_VALUE]) == 0){ 
			stored1[COLLAPSED_VALUE] = stored1[EXPANDED_VALUE];
			stored1[COLLAPSED_VALUE] = stored1[EXPANDED_VALUE];
			if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			stored2[COLLAPSED_INDEX]=stored1[COLLAPSED_INDEX];
		    }
		    else if((stored1[EXPANDED_VALUE]).indexOf(";") != -1 || (stored1[EXPANDED_VALUE]).indexOf(";") != -1){  
			stored1[COLLAPSED_VALUE] = stored1[EXPANDED_VALUE];
			stored2[COLLAPSED_VALUE] = stored2[EXPANDED_VALUE];
			if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			if(stored2[COLLAPSED_INDEX]==null){ stored2[COLLAPSED_INDEX]=stored2[EXPANDED_INDEX];  }
		    }
		    else{
			if(stored1[DISJUNCTION_VALUE] != null){
			    stored2[DISJUNCTION_VALUE]=stored1[DISJUNCTION_VALUE];
			    value = intersectStrings((String)disjunctionHashtable.get(stored2[DISJUNCTION_VALUE]), stored2[EXPANDED_VALUE], "/");
			    disjunctionHashtable.put(stored2[DISJUNCTION_VALUE],value);
			}
			//else{
			//   value = intersectStrings(stored1[EXPANDED_VALUE], stored2[EXPANDED_VALUE], "/");
			//}
			if(value == null){
			    System.out.println("Warning: Feature Equation Invalid at: \n" + 
					       feat1.nodeLabel + " value=" + stored1[EXPANDED_VALUE]);
			    System.out.println(feat2.nodeLabel + " value=" + stored2[EXPANDED_VALUE]); 
			}
			else{ 
			    stored2[COLLAPSED_VALUE]=stored1[COLLAPSED_VALUE] = value; 
			    if(stored1[COLLAPSED_INDEX]==null){ stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];  }
			    stored2[COLLAPSED_INDEX]=stored1[COLLAPSED_INDEX];
			}
		    }
		    featHashtable.put(feat1.id, stored1);
		    featHashtable.put(feat2.id, stored2);
		    break;
		}
		ln2 = ln2.next;
	    }
	    if(!matched){
		if(stored1[COLLAPSED_INDEX] == null){
		    stored1[COLLAPSED_INDEX]=stored1[EXPANDED_INDEX];
		}
		if(stored1[COLLAPSED_VALUE] == null){
		    stored1[COLLAPSED_VALUE]=stored1[EXPANDED_VALUE];
		}
		featHashtable.put(feat1.id, stored1);
	    }
	    result.put(feat1);
	    ln1 = ln1.next;
	}
	// find all features in f2 that have not been matched and add them to the result
	ln2 = f2.head;
	while(ln2.next !=null){
	    feat2 = (Feature)ln2.next.data;
	    if(!feat2.matched){    
		stored2 = (String[])featHashtable.get(feat2.id);
		stored2[COLLAPSED_VALUE]=stored2[EXPANDED_VALUE];
		stored2[COLLAPSED_INDEX]=stored2[EXPANDED_INDEX];
		featHashtable.put(feat2.id, stored2);
		result.put(feat2); 
	    }
	    ln2 = ln2.next;
	}
	return result;
    }
    
    

    
    public String intersectStrings(String s1, String s2, String delimiter){
	String result=null;
	String s2Tokens[];
	StringTokenizer tokenizer1, tokenizer2;
	String token1, token2;
	int t1, t2, i, j;
	// if both strings are the same, return either one
	if(s1.compareTo(s2)==0 || (s1==null && s2==null)){  result = s1;}
	// check which elements in s1 are also in s2
	else if(s1.indexOf(delimiter) !=-1 && s1.indexOf(delimiter)!=-1){
	    // create token for the strings
	    tokenizer1 = new StringTokenizer(s1, delimiter);
	    tokenizer2 = new StringTokenizer(s2, delimiter);
	    // count the number of tokens
	    t1 = tokenizer1.countTokens();
	    t2 = tokenizer2.countTokens();
	    s2Tokens = new String[t2];
	    //insert the tokens into the array
	    for(j=0; j<t2;j++){  s2Tokens[j]=tokenizer2.nextToken(); }
	    for(i=0; i < t1 ; i++){
		token1 = tokenizer1.nextToken();
		for(j=0; j < t2 ; j++){
		    if(token1.compareTo(s2Tokens[j])==0 && result == null){
			result = token1;
			break;
		    }
		    else if(token1.compareTo(s2Tokens[j])==0 && result != null){
			result = result + delimiter+token1;
			break;
		    }
		}
	    }
	}
	// check if s2 is a value in s1
	else if(s1.indexOf(delimiter) != -1){
	    tokenizer1 = new StringTokenizer(s1, delimiter);
	    t1 = tokenizer1.countTokens();
	    for(i=0; i < t1 ; i++){
		token1 = tokenizer1.nextToken();
		if(s2.compareTo(token1)==0){
		    result = s2;
		    break;
		}
	    }
	}
	// check if s1 is a value in s2
	else if(s2.indexOf(delimiter) != -1){
	    tokenizer2 = new StringTokenizer(s2, delimiter);
	    t2 = tokenizer2.countTokens();
	    for(i=0; i < t2 ; i++){
		token2 = tokenizer2.nextToken();
		if(s1.compareTo(token2)==0){
		    result = s1;
		    break;
		}
	    }
	}
	// both 
	else{
	    result=null;
	}
	return result;
    }



    /*
      Name: 
          pushFeatures
      Args:
          TreeNode root: Root of the current subtree
      Returns:
          void
      Description:
          checks to see if the current root is a leaf or an auxfoot. If it is, this is a boundary and ]
	  features cannot be pushed below this point. Return. 
	  Otherwise, if there has been an adjunction at the current root, set the features of the real
	  child. Then proceed with pushing features to the real child and then push features for the first child
	  of the current root
	  If there hasn't been an adjunction, push features for all the children of this current root in order if the
	  features haven't already been set

     */




    public void pushFeatures(TreeNode root){
	TreeNode child;
	boolean terminal=false;
	// if the root node is a leaf or an auxilliary foot, terminate
	if(root.nodeType.compareTo("l") ==0 || root.auxfoot){
	    return;
	}  
	// if there has been adjunction, then make sure that you handle the real child with the right features
	if(root.realChild !=null){
	    // ensure that the real child has the same features as root if it does not already have features defined
	    if(root.realChild.features ==null){
		root.realChild.features = root.features;
	    }
	    pushFeatures(root.realChild);
	    // push the features for the real child that has been relocated by the adjunction
	    pushFeatures(root.fc);
	}
	// process all the nodes in order
	else{
	    child = root.fc;
	    if(child !=null){
		while(!terminal){
		    if(child.features == null){  child.features = root.features; }
		    pushFeatures(child);
		    // if the child does not have its own features, set its features to the features of is parent
		    if(child.terminal){  terminal=true;  }
		    else{  child=child.ns; }
		}
	    }
	}
    }
    

    class FeatListListener implements ItemListener{
	public void itemStateChanged(ItemEvent e){
	    String selectedFeat;
	    String index;
	    ListNode ln;
	    String featArray[], feature;
	    int i,l;
	    java.awt.List list  = (java.awt.List)e.getSource();
	    // get the selected item
	    selectedFeat = list.getSelectedItem();
	    // get the index of the current feature
	    index = selectedFeat.substring(selectedFeat.indexOf("["), selectedFeat.indexOf("]")+1);
	    // loop through listOfFeatureLists 
	    ln = listOfFeatureLists.head;
	    
	    // first clear all the selected items
	    while(ln.next != null){
		// set the entry to selected if co-indexed
		list = (java.awt.List)ln.next.data;
		l = list.getItemCount();
		if(l > 0){
		    for(i=0; i < l ; i++){  list.deselect(i); }
		}
		ln = ln.next;
	    }
	    ln = listOfFeatureLists.head;
	    while(ln.next != null){
		// set the entry to selected if co-indexed
		list = (java.awt.List)ln.next.data;
		if(list.getItemCount() >  0){
		    //System.out.println("starting new list");
		    featArray = list.getItems();
		    l = featArray.length;
		    // for each item in the list, check if it is co-indexed
		    for(i=0; i < l ; i++){
			feature = featArray[i];
			// set selected
			if(feature.indexOf(index) !=-1){
			    list.select(i);
			}
		    }
		}
		ln = ln.next;
	    }
	}
    }
    

}






